(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-314ba913"],{"5b44":function(n,t,e){"use strict";var i=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("v-col",{attrs:{cols:"12"}},[e("v-card",{staticClass:"mx-auto",attrs:{outlined:""}},[e("v-card-title",[n._v("Obrazy")]),e("v-row",{attrs:{dense:""}},[n._l(n.images,(function(n){return e("v-col",{key:n.src,staticClass:"d-sm-none",attrs:{cols:"12"}},[e("v-card",{staticClass:"mx-auto",attrs:{outlined:"","max-width":"95%"}},[e("v-img",{attrs:{alt:n.alt,src:n.src,"max-width":"60%"}})],1)],1)})),n._l(n.images,(function(n){return e("v-col",{key:n.src+"-sm",staticClass:"d-none d-sm-block",attrs:{cols:"6"}},[e("v-card",{staticClass:"mx-auto",attrs:{outlined:"","max-width":"95%"}},[e("v-img",{attrs:{alt:n.alt,src:n.src}})],1)],1)}))],2)],1)],1)},a=[],o={name:"CardImage",props:{images:{type:Array}}},r=o,s=e("2877"),l=e("6544"),c=e.n(l),d=e("b0af"),m=e("99d9"),u=e("62ad"),p=e("adda"),w=e("0fd9b"),z=Object(s["a"])(r,i,a,!1,null,null,null);t["a"]=z.exports;c()(z,{VCard:d["a"],VCardTitle:m["c"],VCol:u["a"],VImg:p["a"],VRow:w["a"]})},"80cb":function(n,t,e){"use strict";e.r(t);var i=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("v-content",[e("v-container",{attrs:{fluid:""}},[e("v-row",{attrs:{dense:""}},[n._l(n.cards,(function(t){return e("Card",n._b({key:t.title},"Card",t,!1))})),e("Implementation",{attrs:{implement:n.implement}}),e("CardImage",{attrs:{images:n.images}})],2)],1)],1)},a=[],o=e("5b44"),r=e("ae8d"),s=e("b7d0"),l={name:"Quicksort",components:{Card:r["a"],CardImage:o["a"],Implementation:s["a"]},data:function(){return{cards:[{title:"Quick Sort",subtitle:"Sortowanie szybkie",flex:12,content:"Jeden z popularnych algorytmów sortowania działających na zasadzie „dziel i zwyciężaj”. Sortowanie QuickSort zostało wynalezione w 1962 przez C.A.R. Hoare’a. Algorytm sortowania szybkiego jest wydajny: jego średnia złożoność obliczeniowa jest rzędu O(n log n). Ze względu na szybkość i prostotę implementacji jest powszechnie używany. Jego implementacje znajdują się w bibliotekach standardowych wielu środowisk programowania."},{title:"Opis",subtitle:"",flex:12,content:"Z tablicy wybiera się element rozdzielający, po czym tablica jest dzielona na dwa fragmenty: do początkowego przenoszone są wszystkie elementy nie większe od rozdzielającego, do końcowego wszystkie większe. Potem sortuje się osobno początkową i końcową część tablicy. Rekursja kończy się, gdy kolejny fragment uzyskany z podziału zawiera pojedynczy element, jako że jednoelementowa tablica nie wymaga sortowania. Jeśli przez l oznacza się indeks pierwszego, a przez r – ostatniego elementu sortowanego fragmentu tablicy, zaś przez i – indeks elementu, na którym tablica została podzielona, to procedurę sortowania można (w dużym uproszczeniu) przedstawić następującym pseudokodem"}],implement:[{lang:"c++",code:'#include <iostream>\n\nusing namespace std;\n\nconst int n = 10;\nint t[n] = {9,0,8,5,6,4,1,2,3,7};\n\nvoid quicksort(int t[], int od, int dok){\n    int pp = od;\n    if(od>=dok) return;\n\n    for(int i=od; i<dok; i++){\n        if(t[i] < t[od]){\n            swap(t[i], t[pp+1]);\n            pp++;\n        }\n    }\n    swap(t[od], t[pp]);\n    quicksort(t, od, pp);\n    quicksort(t, pp+1, dok);\n}\n\nvoid print(int t[], int n){\n    for(int i=0; i<n; i++) cout << t[i] << " ";\n    cout << endl;\n}\n\nint main()\n{\n    quicksort(t, 0,n);\n    print(t, n);\n    return 0;\n}\n'},{lang:"python",code:"def sort(array=[12,4,5,6,7,3,1,15]):\n\nless = []\nequal = []\ngreater = []\n\nif len(array) > 1:\n    pivot = array[0]\n\n    for x in array:\n        if x < pivot:\n            less.append(x)\n\n        elif x == pivot:\n            equal.append(x)\n\n        elif x > pivot:\n            greater.append(x)\n\n    return sort(less) + equal + sort(greater)  \nelse: \n    return array"},{lang:"javascript",code:"let items = [5,3,7,6,2,9];\nfunction swap(items, leftIndex, rightIndex){\n    var temp = items[leftIndex];\n    items[leftIndex] = items[rightIndex];\n    items[rightIndex] = temp;\n}\nfunction partition(items, left, right) {\n    let pivot   = items[Math.floor((right + left) / 2)], \n        i       = left,\n        j       = right; \n    while (i <= j) {\n        while (items[i] < pivot) {\n            i++;\n        }\n        while (items[j] > pivot) {\n            j--;\n        }\n        if (i <= j) {\n            swap(items, i, j); \n            i++;\n            j--;\n        }\n    }\n    return i;\n}\n\nfunction quickSort(items, left, right) {\n    let index;\n    if (items.length > 1) {\n        index = partition(items, left, right); \n        if (left < index - 1) { \n            quickSort(items, left, index - 1);\n        }\n        if (index < right) { \n            quickSort(items, index, right);\n        }\n    }\n    return items;\n}\n\nlet sortedArray = quickSort(items, 0, items.length - 1);\nconsole.log(sortedArray); // [2,3,5,6,7,9]"}],images:[{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Sorting_quicksort_anim.gif/240px-Sorting_quicksort_anim.gif",alt:"Gif obrazujący działanie sortowania szybkiego"}]}}},c=l,d=e("2877"),m=e("6544"),u=e.n(m),p=e("a523"),w=e("a75b"),z=e("0fd9b"),g=Object(d["a"])(c,i,a,!1,null,null,null);t["default"]=g.exports;u()(g,{VContainer:p["a"],VContent:w["a"],VRow:z["a"]})}}]);
//# sourceMappingURL=chunk-314ba913.b4924654.js.map